global n q0 start
start = true;

h       = 0.01;             % sample time (s)
simTime = 100;              % simulation duration in seconds
Ns      = simTime/h;        % number of samples
t       = zeros(1, Ns);     % array of simulation time steps
                            % (updated in loop)

N = n + 2; % number of all virtual and real links

% Allocate memory
M = zeros(N,N);
C = zeros(N,1);
q         = zeros(N,Ns);
q_dot     = zeros(N,Ns);
q_dot_dot = zeros(N,Ns);

% Initial values
q(:,1)    = q0;

tau_motor       = zeros(N,1); % motor torque
tau_motor(2,1)  = 0.01;
tau_motor(3,1)  = 0.01;
tauc            = zeros(N,1); % torque from constraint
tau             = zeros(N,1);


%% Main simulation loop
for k = 1:Ns-1
  t(k+1) = k*h;
  
  tau = tau_motor + tauc;
  
  % Calculate dynamics matrices
  M = M_func(q(:,k)');
  C = C_func(q(:,k)', q_dot(:,k)', q_dot_dot(:,k)');   
  
  % Calculate joint acceleration
  q_dot_dot(:,k) = pinv(M)*(tau - C');
  
  
  for i = 2:n
    % Links can't cross each other
    if (q(i,k) > pi || q(i,k) < -pi)
      q(i,k+1) = pi*sign(q(i,k))*1;%0.99;
      q_dot(i,k+1) = 0;
      q_dot_dot(i,k+1) = 0;
    else
      % Euler integration
      q_dot(i,k+1)     = q_dot(i,k) + q_dot_dot(i,k)*h;
      q(i,k+1)         = q(i,k) + q_dot(i,k)*h;
    end
  end
  
  % Fi
  
  
  % Calculate link coordinates
  pos = kinematics(q(:,k));
  
  % Calculate torque from contact
  tauc = calc_tauc(pos, q(:,k), tau_motor);
  tauc = zeros(N,1);
  
  x0 = q(n+1,k);
  y0 = q(n+2,k);
  
  % Visualize robot
  visualize(pos, x0, y0);
  
end